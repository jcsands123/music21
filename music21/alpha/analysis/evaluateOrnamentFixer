from music21 import *
from music21.alpha.analysis import hasher
from music21.alpha.analysis import aligner
from music21.alpha.analysis import fixer

from copy import deepcopy

###### GLOBAL VARIABLES (correctionState) ######
DISCREPANCY = "discrepancy"
CONFIDENT_FIX = "confident fix"
TENTATIVE_FIX = "tentative fix"
NO_DISCREPANCY = "no discrepancy"
TESTING = "testing"


###### HELPER FUNCTIONS ######
def shiftMusic(streamToShift, durationToShift, shiftRight=True, skipLayout=True):
    '''
    returns a copy of the streamToShift moved durationToShift to the right or left

    streamToShift is a stream, possibly composed of multiple substreams
    durationToShift is a duration.Duration
    shiftRight indicates whether the shift should be to the left or the right
    when skip layout is true, ignores layouts (mostly)

    can only shift for streams where shifting would allow previous meter changes to stay at starts of measures
    when no time signature is provided, uses the default one of music21 (4/4)

    TODO: deal with end bar line, key signatures, codas and friends, spanners, skippingLayout fully,
        chords and rests that go over the bar line
    '''
    eps = 10e-5

    newStream = deepcopy(streamToShift) # so that returns correct type of stream
    newStream.clear()

    # deal with stream made up of substreams
    hasSubstreams = any(isinstance(x, stream.Stream) and not isinstance(x, stream.Measure) for x in streamToShift)
    if hasSubstreams:
        subStreamMapping = {}

        # recursively deal with substreams
        for x in streamToShift:
            if isinstance(x, stream.Stream):
                shiftedSubStream = shiftMusic(x, durationToShift, shiftRight, skipLayout)
                shiftedSubStream.id = x.id
                newStream.append(shiftedSubStream)
                subStreamMapping[x] = newStream
            # TODO want skip all layout??
            # elif skipLayout and isinstance(x, (layout.PageLayout, layout.SystemLayout, layout.ScoreLayout)):
            #     continue
            else:
                newStream.append(x)

        # update spanners
        for spannerToUpdate in newStream.getElementsByClass(spanner.Spanner):
            for origSpanElem in spannerToUpdate.getSpannedElements():
                if origSpanElem in subStreamMapping:
                    newSpanElem = subStreamMapping[origSpanElem]
                    spannerToUpdate.replaceSpannedElement(origSpanElem, newSpanElem)

        # all done
        return newStream

    # at this point, no substreams in stream

    # make sure stream has measures
    preppedStreamToShift = deepcopy(streamToShift)
    if not preppedStreamToShift.hasMeasures():
        preppedStreamToShift = preppedStreamToShift.makeMeasures()

    # redo creating stream to return
    newStream = deepcopy(preppedStreamToShift)  # so that returns correct type of stream
    newStream.clear()

    # copy metadata
    newStream.metadata = streamToShift.metadata

    # For keeping State
    lastTimeSigSeen = None
    justSawTimeSigOutsideMeasure = False
    fullMeasureDurationQl = 100000.0 # maybe should be none?
    measureLeftPickupOffsetQl = None

    fillingMeasure = stream.Measure()
    isFirstMeasure = True
    isAfterRepeatMeasure = False
    afterRepeatOffset = None

    # Internal Helper Functions
    def getAmountFull(measure, fullDurationQl):
        '''
        returns number of quarter lengths in the measure (stream)
        when a full measure has fullDurationQl (number)
        '''
        mDuration = duration.Duration(fullDurationQl)
        amount = fullDurationQl * measure.barDurationProportion(barDuration=mDuration)
        return amount

    def initTimeSignature(timeSignature, measurePaddingLeft = 0):
        '''
        given a timeSignature and number of padding on the left of that measure,
        return a tuple (mDurationQl, offsetQl) where
        mDurationQl is the number of quarter lengths in a full measure (a number)
        offsetQl is the left offset of the pickup measure (a number)
        '''
        mDurationQl = timeSignature._getBarDuration().quarterLength
        shiftRightOffsetQl = (durationToShift.quarterLength) % mDurationQl
        shiftLeftOffsetQl = (mDurationQl - shiftRightOffsetQl) % mDurationQl

        if shiftRight:
            offsetQl = (shiftRightOffsetQl + measurePaddingLeft) % mDurationQl
        else:
            offsetQl = (shiftLeftOffsetQl + measurePaddingLeft) %  mDurationQl

        return mDurationQl, offsetQl

    # Bulk of copying over musical content
    for x in preppedStreamToShift:
        if isinstance(x, stream.Measure):
            m = x
            if justSawTimeSigOutsideMeasure and not lastTimeSigSeen is None:
                fullMeasureDurationQl, measureLeftPickupOffsetQl = initTimeSignature(lastTimeSigSeen, m.paddingLeft)
                # lastTimeSigSeen set when justSawTimeSigOutsideMeasure set to True
                justSawTimeSigOutsideMeasure = False
            if isinstance(m.leftBarline, bar.Repeat) and (isAfterRepeatMeasure or isinstance(newStream.measure(-1).rightBarline, bar.Repeat)):
                fillingMeasure.leftBarline = deepcopy(m.leftBarline)
            for elem in m:
                if isinstance(elem, meter.TimeSignature):
                    # save time signature settings
                    fullMeasureDurationQl, measureLeftPickupOffsetQl  = initTimeSignature(elem, m.paddingLeft)
                    lastTimeSigSeen = elem
                if skipLayout and isinstance(elem, (layout.PageLayout, layout.SystemLayout)):
                    # layouts no longer applicable because notes shifting
                    continue
                if isinstance(elem, bar.Repeat):
                    # repeat signs added in a different way
                    continue
                if isinstance(elem, note.GeneralNote):
                    if isFirstMeasure and measureLeftPickupOffsetQl is None:
                        # use default time signature when unknown
                        defaultTimeSig = meter.TimeSignature()
                        fullMeasureDurationQl, measureLeftPickupOffsetQl = initTimeSignature(defaultTimeSig, m.paddingLeft)
                        lastTimeSigSeen = defaultTimeSig
                        fillingMeasure.append(defaultTimeSig)

                    spaceNeeded = elem.duration.quarterLength
                    amountFull = getAmountFull(fillingMeasure, fullMeasureDurationQl)
                    spaceLeft = fullMeasureDurationQl - amountFull

                    if isFirstMeasure:
                        spaceLeft -= measureLeftPickupOffsetQl
                    elif isAfterRepeatMeasure:
                        if afterRepeatOffset is None:
                            # more of an internal error, shouldn't happen
                            raise ValueError("After Repeat Offset shouldn't be none")
                        spaceLeft -= afterRepeatOffset

                    # place note
                    if spaceLeft > spaceNeeded + eps:
                        # space for note and enough space for another note after
                        noteCopy = deepcopy(elem)
                        fillingMeasure.append(noteCopy)
                    else:
                        noteFitsCompletely = abs(spaceLeft - spaceNeeded) <= eps

                        # 1. deal with first note
                        if noteFitsCompletely:
                            noteCopy = deepcopy(elem)
                            fillingMeasure.append(noteCopy)
                        else:
                            # split note between measures
                            n1 = deepcopy(elem)

                            if elem.tie is None:
                                n1.tie = tie.Tie("start")
                            elif elem.tie.style == "continue" or elem.tie.style == "stop":
                                n1.tie = tie.Tie("continue")
                            else:  # elem.tie.style == "start'
                                n1.tie = tie.Tie("start")

                            n1.duration = duration.Duration(spaceLeft)
                            fillingMeasure.append(n1)

                        # 2. finish current measure and start another
                        # pad measure when done with it if first measure
                        if (isFirstMeasure or isAfterRepeatMeasure) and measureLeftPickupOffsetQl != 0:
                            fillingMeasure.padAsAnacrusis()
                        newStream.append(fillingMeasure)
                        # make new next measure
                        fillingMeasure = stream.Measure()
                        isFirstMeasure = False
                        isAfterRepeatMeasure = False

                        # 3. deal with possible second note (tied in)
                        # shouldn't need to make a 3rd note because the 2nd note always fits into the new measure
                        if not noteFitsCompletely:
                            # put n2 in next measure
                            n2 = deepcopy(elem)
                            if elem.tie is not None and elem.tie.style == "continue":
                                n2.tie = tie.Tie("continue")
                            else:
                                n2.tie = tie.Tie("stop")

                            n2.tie = tie.Tie("stop")
                            n2.duration = duration.Duration(spaceNeeded - spaceLeft)
                            fillingMeasure.append(n2)
                else: # not a note.GeneralNote
                    elemCopy = deepcopy(elem)
                    fillingMeasure.append(elemCopy)
            if m.rightBarline is not None and isinstance(m.rightBarline, bar.Repeat):
                amountFull = getAmountFull(fillingMeasure, fullMeasureDurationQl)
                if amountFull == 0:
                    # will really only happen if shifting by %0
                    lastMeasureAdded = newStream.measure(-1)
                    lastMeasureAdded.rightBarline = m.rightBarline
                else:
                    fillingMeasure.rightBarline = m.rightBarline
                    isAfterRepeatMeasure = True
                    afterRepeatOffset = amountFull

                    # finish current measure and start another
                    newStream.append(fillingMeasure)
                    fillingMeasure = stream.Measure()
        else:
            if isinstance(x, meter.TimeSignature):
                # save time signature settings
                # but dont calculate related fields yet because need to know left offset of first measure after
                justSawTimeSigOutsideMeasure = True
                lastTimeSigSeen = x
            newStream.append(deepcopy(x))

    # include last measure filling up
    if getAmountFull(fillingMeasure, fullMeasureDurationQl) != 0:
        newStream.append(fillingMeasure)
        # never need to pad as anacrusis
        # since will not contain pickups to another measure since no measure after

    # TODO Redo spanners

    # rebeam and clear stem directions
    newStream.makeBeams(inPlace=True)
    newStream.makeRests(inPlace=True)
    newStream.makeAccidentals(inPlace=True)
    for n in newStream.flat.notes:
        n.stemDirection = None
    return newStream

# # Testing shifting score
# bach = corpus.parse('bach/bwv108.6.xml')
# shifted = shiftMusic(bach, duration.Duration(.5), shiftRight=False)

def rehearsalMarkFromTablature(chordTab):
    '''
    Converts misread chord tablature marking into the
    rehearsal letter marking.
    So chord for A, turns into Rehearsal Mark "A".

    :param chordTab: music21 tablature.ChordWithFretBoard
    :return: expressions.RehearsalMark
    '''
    letter = chordTab.figure
    return expressions.RehearsalMark(letter)

def replaceTablaturesWithRehearsalMarks(s):
    '''
    Replaces all tablature.ChordWithFretBoard in a stream
    with a rehearsal mark with the appropriate letter
    according to rehearsalMarkFromTablature
    :param s: music21 stream
    '''
    for chordTab in s.recurse(classFilter="ChordWithFretBoard"):
        s.replace(chordTab, rehearsalMarkFromTablature(chordTab))

def adjustKey(omrStream, midiStream):
    '''
    Modifies the key of midiStream when each stream has exactly one unique key
    the keys are different and the omrStream has the predicted key.
    TODO: should be able to fix more situations
    :param omrStream:
    :param midiStream:
    '''
    bestKey = midi.analyze('key')
    bestKeySignature = key.KeySignature(bestKey.sharps)

    omrKeySignatures = list(omrStream.recurse(classFilter="KeySignature"))
    midiKeySignatures = list(midiStream.recurse(classFilter="KeySignature"))

    # These three cases which might be able to account for, but for simplicity now, don't
    if len(omrKeySignatures) == 0 or len(midiKeySignatures) == 0:
        # one has a key signature and the other doesn't
        return
    if not all(k.sharps == omrKeySignatures[0].sharps for k in omrKeySignatures):
        # omr has more than one unique key signature
        return
    if not all(k.sharps == midiKeySignatures[0].sharps for k in midiKeySignatures):
        # midi has more than one unique key signature
        return

    # at this point, have lists with at least one key but all are the same key
    omrKeySignature = omrKeySignatures[0]
    midiKeySignature = midiKeySignatures[0]
    bestKeyIsOmrKey = omrKeySignature.sharps == bestKey.sharps
    if omrKeySignature != midiKeySignature and bestKeyIsOmrKey:
        for k in midiKeySignatures:
            k.sharps = bestKey.sharps

def clearStyle(s):
    '''
    Clear style of all elements in stream s
    '''
    for elem in s.recurse():
        elem.style = None

def markConfidentFix(elem):
    '''
    Sets correctionStatus of elem's editorial to "confident fix"
    '''
    elem.editorial.correctionStatus = CONFIDENT_FIX

def markTentativeFix(elem):
    '''
    Sets correctionStatus of elem's editorial to "tentative fix"
    '''
    elem.editorial.correctionStatus = TENTATIVE_FIX

def getNextRests(startingRest, *, referenceStream=None, returnOrig = False):
    '''
    Gets the next consecutive rests as a new stream from and including startingRest
    When referenceStream is defined, uses active site in reference stream for startingRest
    Returns either the original or a deepcopy of the rests

    Consecutive rests can be interrupted by barlines, but cannot be interrupted by notes or chords
    '''
    if referenceStream:
        startingRest.activeSite = referenceStream

    rests = stream.Stream()
    nextElem = startingRest.next('GeneralNote', activeSiteOnly=True)

    if returnOrig:
        rests.append(startingRest)
    else:
        rests.append(deepcopy(startingRest))

    while nextElem:
        if not nextElem.isRest:
            break

        currentRest = nextElem
        nextElem = currentRest.next('GeneralNote', activeSiteOnly=True)

        if returnOrig:
            rests.append(currentRest)
        else:
            rests.append(deepcopy(currentRest))
    return rests

def replaceSnippet(snippetToRemove, snippetToAdd, operateOnStream):
	'''
	Replaces snippetToRemove with snippetToAdd in operateOnStream (all streams)

	All notes in snippetToRemove must exist in operateOnStream.

	Currently, elements in snippetToRemove must exist in the same hierarchical stream in operateOnStream
	(ie the same measure)

	snippetToRemove and snippetToAdd must have the same total duration
	'''
	firstElementToRemove = snippetToRemove.elements[0]
	containerToRemoveFrom = operateOnStream.containerInHierarchy(firstElementToRemove)
	newContainer = containerToRemoveFrom.cloneEmpty()

	addedElements = False

	for origElem in containerToRemoveFrom.recurse():
		if origElem in snippetToRemove:
			if not addedElements:
				for addElem in snippetToAdd:
					newContainer.append(addElem)
				addedElements = True
			else:
				continue
		else:
			newContainer.append(origElem)

	operateOnStream.replace(containerToRemoveFrom, newContainer)

###### CORRECTOR ######
# TODO: Is there a better name?
class Corrector:
    def __init__(self, midiStream, omrStream, groundTruthStream = None, partNum = 0):
        '''
        :param midiStream: stream generated from MIDI used to help fix omrStream
        :param omrStream: stream generated from OMR software to modify
        :param groundTruthStream: (optional) the desired output
        :param partNum: the specific part to compare
        '''
        #
        self.confidentFixColor = "green" # CONFIDENT_FIX
        self.tentativeFixColor = "orange" # TENTATIVE_FIX
        self.discrepancyColor = "red" # DISCREPANCY
        self.noDiscrepancyColor = "black" # NO_DISCREPANCY
        self.testingColor = "purple" # TESTING... just for internal debugging purposes

        self.eps = 10e-5 # for fuzzy comparison
        self.partNum = partNum
        self.canCorrect = False # Only turns true once set up is completed and it says can correct
        self.hasBeenAligned = False # Only turns true once align has been called

        # These never change for a reference point to look back to
        # Are original passed in streams so careful modifying (for now, don't)
        self.midiOriginal = midiStream
        self.omrOriginal = omrStream
        self.groundTruth = groundTruthStream
        self.groundTruthPart = None # set in set up

        # before aligned, these will be modified in set up so alignment can happen
        self.midiModifiedForAlignment = deepcopy(midiStream)
        self.omrModifiedForAlignment = deepcopy(omrStream)

        # after aligned (these are parts)
        self.midiPartGenerations = [] # [origModifiedForAlignment, pre0, post0, pre1 (copy of last pre), post1, ...]
        self.omrPartGenerations = []  # [origModifiedForAlignment, pre0, post0, pre0 (copy of last pre), post1, ...]
        # TODO: should currentGeneration be tracked as another variable?

        # Updated each time for current generation of pre and post of midi and omr
        self.omrPreIdToElem = {}
        self.omrPostIdToElem = {}
        self.omrPreIdToOmrPostId = {}
        self.omrPostIdToOmrPreId = {}

        self.omrPreIdToMidiPreIdNoChange = {} # preId: postId (when change is aligner.ChangeOps.NoChange)
        self.omrPreIdToMidiPreIdAllChanges = {}  # preId: [(midiId, change), (midiId, change), (midiId, change)] # aka all notes that come from it
        self.omrPreIdToMidiPreIdRealChanges = {} # same format as self.omrPreIdToMidiPreIdAllChanges, but doesn't include aligner.ChangeOps.NoChange

        self.midiPreIdToElem = {}
        self.midiPostIdToElem = {}
        self.midiPostIdToMidiPreId = {}
        self.midiPreIdToMidiPostId = {}

        # TODO: should setUp be called in the init??

    def setUp(self):
        '''
        Sets up so the parts can be aligned:
            - Shifts self.midiModifiedForAlignment so measures line up with omr
                for now, just shifts right half a beat --> TODO: make generalizable
            - Adjusts self.midiModifiedForAlignment key to match key of omr if different and possible
            - Replaces tablatures with rehearsal marks in OMR

        Collects specific parts for MIDI, OMR, and groundtruth (if applicable)

        Puts first 3 entries in omr and midi generation lists

        :return: tuple of whether set up was successful and error if any (or None)
        (bool success, error)
        '''
        self.canCorrect = False # set true if makes to end of the function

        self.midiModifiedForAlignment = repeat.RepeatFinder(self.midiModifiedForAlignment).simplify()
        self.midiModifiedForAlignment = shiftMusic(self.midiModifiedForAlignment, duration.Duration(.5), shiftRight=False)
        replaceTablaturesWithRehearsalMarks(self.omrModifiedForAlignment)
        adjustKey(self.omrModifiedForAlignment, self.midiModifiedForAlignment)
        # TODO throw error if # measures is still not the same at this point! (if omr misreads a repeat, this unrecoverable)

        # Set parts
        if self.groundTruth is not None:
            if isinstance(self.groundTruth, stream.Part):
                self.groundTruthPart = self.groundTruth
            else:
                if len(self.groundTruth.parts) <= self.partNum:
                    return (False, ValueError("Ground truth doesn't have " + partNum + " parts"))
                self.groundTruthPart = self.groundTruth.parts[self.partNum]

        if isinstance(self.midiModifiedForAlignment, stream.Part):
            midiPrePart = self.midiModifiedForAlignment
        else:
            if len(self.midiModifiedForAlignment.parts) <= self.partNum:
                return (False, ValueError("MIDI doesn't have " + partNum + " parts"))
            midiPrePart = self.midiModifiedForAlignment.parts[self.partNum]

        if isinstance(self.omrModifiedForAlignment, stream.Part):
            omrPrePart = self.omrModifiedForAlignment
        else:
            if len(self.omrModifiedForAlignment.parts) <= self.partNum:
                return (False, ValueError("OMR doesn't have " + partNum + " parts"))
            omrPrePart = self.omrModifiedForAlignment.parts[self.partNum]

        # add these originals before alignment
        self.omrPartGenerations = [omrPrePart]
        self.midiPartGenerations = [midiPrePart]

        self.makeNewPrePostGeneration()
        self.canCorrect = True
        return (True, None) # success if got to this point!

    def makeNewPrePostGeneration(self):
        '''
        Adds a new generation to self.omrPartGenerations and self.midiPartGenerations
        where a generation consists of a pre and post
        where pre is a copy of last generation's post
        and post is a copy of the current generation's pre
        TODO: should raise an error if self.omrPartGenerations or self.midiPartGenerations are empty?
        '''
        newMidiPre = deepcopy(self.getMidiPost()) # returns same as getMidiUnaligned when no generations
        clearStyle(newMidiPre)
        newMidiPost = deepcopy(newMidiPre)
        self.midiPartGenerations.append(newMidiPre)
        self.midiPartGenerations.append(newMidiPost)

        newOmrPre = deepcopy(self.getOmrPost()) # returns same as getOmrUnaligned when no generations
        clearStyle(newOmrPre)
        newOmrPost = deepcopy(newOmrPre)
        self.omrPartGenerations.append(newOmrPre)
        self.omrPartGenerations.append(newOmrPost)

    def getOmrPost(self, generation=None): # generation starts at 0
        '''
        Gets latest OmrPost or from a specific zero-indexed generation number when provided

        When no generations exists, returns same as getOmrUnaligned()
        :param generation: int
        :return: stream for omr post
        '''
        if generation is None: # return latest
            return self.omrPartGenerations[-1]
        i = generation * 2 + 2 # TODO make sure not out of range
        return self.omrPartGenerations[i]

    def getMidiPost(self, generation=None):
        '''
        Gets latest MidiPost or from a specific zero-indexed generation number when provided

        When no generations exists, returns same as getMidiUnaligned()
        :param generation: int
        :return: stream for midi post
        '''
        if generation is None: # return latest
            return self.midiPartGenerations[-1]
        i = generation * 2 + 2  # TODO make sure not out of range
        return self.midiPartGenerations[i]

    def getOmrPre(self, generation = None):
        '''
        Gets latest OmrPre or from a specific zero-indexed generation number when provided
        :param generation: int
        :return: stream for omr pre
        '''
        if generation is None: # return latest
            return self.omrPartGenerations[-2]
        i = generation * 2 + 1  # TODO make sure not out of range
        return self.omrPartGenerations[i]

    def getMidiPre(self, generation = None):
        '''
        Gets latest MidiPre or from a specific zero-indexed generation number when provided
        :param generation: int
        :return: stream for midi pre
        '''
        if generation is None: # return latest
            return self.midiPartGenerations[-2]
        i = generation * 2 + 1 # TODO make sure not out of range
        return self.midiPartGenerations[i]

    def getOmrUnaligned(self):
        '''
        :return: first omr part modified and copied from original, but before aligned
        '''
        return self.omrPartGenerations[0]

    def getMidiUnaligned(self):
        '''
        :return: first midi part modified and copied from original, but before aligned
        '''
        return self.midiPartGenerations[0]

    def clearReferences(self):
        '''
        Resets all reference dictionaries to reference between pre and post, omr and midi for current generation
        '''
        # TODO should these be saved in a list instead of rewritten each time?
        self.omrPreIdToElem = {}
        self.omrPostIdToElem = {}
        self.omrPreIdToOmrPostId = {}
        self.omrPostIdToOmrPreId = {}
        self.omrPreIdToMidiPreIdNoChange = {}
        self.omrPreIdToMidiPreIdAllChanges = {}
        self.omrPreIdToMidiPreIdRealChanges = {}
        self.midiPreIdToElem = {}
        self.midiPostIdToElem = {}
        self.midiPostIdToMidiPreId = {}
        self.midiPreIdToMidiPostId = {}

    def align(self):
        '''
        Aligns the latest generation of omr and midi
        Sets self.hasBeenAligned to be true once finished
        Does not return anything
        '''
        # do aligning
        streamAligner = aligner.StreamAligner(
            sourceStream=self.getOmrPre(),
            targetStream=self.getMidiPre()
        )
        streamAligner.align()
        streamAligner.showChanges()

        # must clear out these mappings (since currently for the previous generation)
        self.clearReferences()

        # set up references to reference between streams
        for omrPreElem in self.getOmrPre().recurse():
            self.omrPreIdToElem[omrPreElem.id] = omrPreElem

        for omrPostElem in self.getOmrPost().recurse():
            self.omrPostIdToElem[omrPostElem.id] = omrPostElem
            preElemCopiedFrom = omrPostElem.derivation.origin
            if preElemCopiedFrom is None:  # case for P1: Violin I: Violin
                continue
            self.omrPreIdToOmrPostId[preElemCopiedFrom.id] = omrPostElem.id
            self.omrPostIdToOmrPreId[omrPostElem.id] = preElemCopiedFrom.id

        for midiPreElem in self.getMidiPre().recurse():
            self.midiPreIdToElem[midiPreElem.id] = midiPreElem

        for midiPostElem in self.getMidiPost().recurse():
            self.midiPostIdToElem[midiPostElem.id] = midiPostElem
            preElemCopiedFrom = midiPostElem.derivation.origin
            if preElemCopiedFrom is None: # case for P1: Violin I: Violin
                continue
            self.midiPreIdToMidiPostId[preElemCopiedFrom.id] = midiPostElem.id
            self.midiPostIdToMidiPreId[midiPostElem.id] = preElemCopiedFrom.id

        for midiNoteRef, omrPreNoteRef, change in streamAligner.changes:
            # skip the occasional things that got in there that shouldn't be there
            if omrPreNoteRef.id not in self.omrPreIdToElem.keys() or midiNoteRef.id not in self.midiPreIdToElem.keys():
                continue

            if change == aligner.ChangeOps.NoChange:  # save no changes
                self.omrPreIdToMidiPreIdNoChange[omrPreNoteRef.id] = midiNoteRef.id
            elif omrPreNoteRef.id not in self.omrPreIdToMidiPreIdRealChanges:  # save other changes
                self.omrPreIdToMidiPreIdRealChanges[omrPreNoteRef.id] = [(midiNoteRef.id, change)]
            else:
                self.omrPreIdToMidiPreIdRealChanges[omrPreNoteRef.id].append((midiNoteRef.id, change))

            # save all changes
            if omrPreNoteRef.id not in self.omrPreIdToMidiPreIdAllChanges:
                self.omrPreIdToMidiPreIdAllChanges[omrPreNoteRef.id] = [(midiNoteRef.id, change)]
            else:
                self.omrPreIdToMidiPreIdAllChanges[omrPreNoteRef.id].append((midiNoteRef.id, change))

        # Marking correction status of elements in omrPost
        # TODO: maybe should do for midiPost too?
        for omrPostElem in self.getOmrPost().recurse():
            if omrPostElem.id not in self.omrPostIdToOmrPreId:
                continue
            omrPreId = self.omrPostIdToOmrPreId[omrPostElem.id]

            if omrPreId in self.omrPreIdToMidiPreIdNoChange:
                if "correctionStatus" in omrPostElem.editorial:
                    previousCorrectionStatus = omrPostElem.editorial.correctionStatus
                    if previousCorrectionStatus == DISCREPANCY:
                        # In this case, fairly confident this was a side effect of aligning
                        # that was "fixed" by other things being fixed
                        markConfidentFix(omrPostElem)
                    # otherwise in the case of TENTATIVE_FIX, CONFIDENT_FIX, would appear resolved in alignment, but only looks resolved because of the fix
                    # and don't want to rewrite over that nuanced fixing information
                    # in case of NO_DISCREPANCY before and now, no need to change it!
                else:
                    omrPostElem.editorial.correctionStatus = NO_DISCREPANCY
            elif omrPreId in self.omrPreIdToMidiPreIdRealChanges: # has real change
                omrPostElem.editorial.correctionStatus = DISCREPANCY

        self.hasBeenAligned = True

    def omrPreElemToOmrPostElem(self, omrPreElem):
        '''
        :param omrPreElem: music21 element in latest generation of omrPre
        :return: corresponding element in latest generation of omrPost
        TODO: should error be returned or raised?
        '''
        if omrPreElem.id not in self.omrPreIdToOmrPostId.keys():
            raise ValueError("No mapping available for  " + omrPreElem)
        omrPostElemId = self.omrPreIdToOmrPostId[omrPreElem.id]
        omrPostElem = self.omrPostIdToElem[omrPostElemId]
        return omrPostElem

    def omrPreElemToMidiPreElemAndChange(self, omrPreElem, getAll=False):
        '''
        :param omrPreElem: music21 element in the latest generation of omrPre
        :param getAll: whether should get first (False) element "aligns" with
        or all elements that derive from it in the alignment (True)
        :return: tuple of corresponding midi element and change to get to that element
                or a list of these tuples (when getAll= True)
        '''
        if omrPreElem.id not in self.omrPreIdToMidiPreIdAllChanges.keys():
            raise ValueError("No mapping available for  " + omrPreElem)
        if getAll:
            return self.omrPreIdToMidiPreIdAllChanges[omrPreElem.id]
        else:
            return self.omrPreIdToMidiPreIdAllChanges[omrPreElem.id][0] # returns just the first

    def midiPreElemToMidiPostElem(self, midiPreElem):
        '''
        :param midiPreElem: music21 element in latest generation of midiPre
        :return: corresponding element in latest generation of midiPost
        TODO: should error be returned or raised?
        '''
        if midiPreElem.id not in self.midiPreIdToMidiPostId.keys():
            raise ValueError("No mapping available for  " + midiPreElem)
        midiPostElemId = self.midiPreIdToMidiPostId[midiPreElem.id]
        midiPostElem = self.midiPostIdToElem[midiPostElemId]
        return midiPostElem

    def getCorrespondingElementsFromPreId(self, omrPreId, changeList):
        '''
        Gets corresponding elements to the pre element in the other streams

        :param omrPreId: id corresponding to a music21 element in the omrPre stream of current generation
        :param changeList: list of tuples (correspondingMidiPreElemId, change to get to that midi from omr)
        :return: list of the corresponding [omrPreElem, omrPostElem, midiPreElem, midiPostElem]
            for current generation or None if cannot find references for these elements
        '''
        if omrPreId not in self.omrPreIdToElem.keys():
            return None
        problematicOmrPreElem = self.omrPreIdToElem[omrPreId]
        correspondingMidiPreElemId, correspondingChange = changeList[0]
        if correspondingMidiPreElemId not in self.midiPreIdToElem.keys():
            return None

        # Get corresponding elements
        correspondingMidiPreElem = self.midiPreIdToElem[correspondingMidiPreElemId]
        correspondingOmrPostElem = self.omrPostIdToElem[self.omrPreIdToOmrPostId[omrPreId]]
        correspondingMidiPostElem = self.midiPreElemToMidiPostElem(correspondingMidiPreElem)

        return [problematicOmrPreElem, correspondingOmrPostElem, correspondingMidiPreElem, correspondingMidiPostElem]

    def fixerHelperDifferentRestRep(self, omrPreId, changeList):
        '''
        Fixes when omr and midi have rests totalling the same duration, but with different representation
        Modifies omrPost and midiPost of current generation and adds editorial info about fix if fixes

        :param omrPreId: id corresponding to a music21 element in the omrPre stream of current generation
        :param changeList: list of tuples (correspondingMidiPreElemId, change to get to that midi from omr)
        :return: tuple: (bool fixedSomething, set omrPreIdsToIgnore, set midiPreIdsToIgnore)
        '''
        correspondingElements = self.getCorrespondingElementsFromPreId(omrPreId, changeList)
        if correspondingElements is None:
            return (False, set(), set())
        omrPreElem, omrPostElem, midiPreElem, midiPostElem = correspondingElements

        omrPreIdsToIgnore = set()
        midiPreIdsToIgnore = set()

        if not omrPreElem.isRest or not omrPostElem.isRest:
            return (False, set(), set())

        nextOmrPreRests = getNextRests(omrPreElem, returnOrig=True)
        nextMidiPreRests = getNextRests(midiPreElem, returnOrig=True)

        # if these rests are them same, don't try to fix
        if len(nextOmrPreRests.elements) == len(nextMidiPreRests.elements):
            sameRests = True
            for i in range(len(nextOmrPreRests.elements)):
                if nextOmrPreRests.elements[i].duration.quarterLength != nextMidiPreRests.elements[i].duration.quarterLength:
                    sameRests = False
                    break
            if sameRests: # the rests are the same
                return (False, set(), set())

        if abs(nextOmrPreRests.duration.quarterLength - nextMidiPreRests.duration.quarterLength) <= self.eps:
            # Detected: both parts have same total duration of rests, but represented differently
            # Fix: keep omr rests, confidently
            nextOmrPostRests = getNextRests(omrPostElem, returnOrig=True)
            for okRest in nextOmrPostRests.recurse():
                markConfidentFix(okRest)
            nextMidiPostRests = getNextRests(midiPostElem, returnOrig=True)
            # will copy in the confident fix on these elements
            replaceSnippet(nextMidiPostRests, nextOmrPostRests, self.getMidiPost())

            # update dont touch ids so that dont try to fix anything else with these rests
            for omrPreRest in nextOmrPreRests.recurse():
                omrPreIdsToIgnore.add(omrPreRest.id)
                restChangesList = self.omrPreIdToMidiPreIdRealChanges[omrPreRest.id]
                for i, c in restChangesList:
                    midiPreIdsToIgnore.add(i)
            for nextMidiRest in nextMidiPreRests.recurse():
                midiPreIdsToIgnore.add(nextMidiRest.id)
            for i, c in changeList:
                midiPreIdsToIgnore.add(i)
            return (True, omrPreIdsToIgnore, midiPreIdsToIgnore)

        return (False, omrPreIdsToIgnore, midiPreIdsToIgnore)

    def fixerHelperPitchAccidentals(self, omrPreId, changeList):
        '''
        Fixes when omr and midi have different pitches because of different enharmonic representations of the pitch
        or missing or misread accidentals in the omr part
        Modifies omrPost and midiPost of current generation and adds editorial info about fix if fixes

        :param omrPreId: id corresponding to a music21 element in the omrPre stream of current generation
        :param changeList: list of tuples (correspondingMidiPreElemId, change to get to that midi from omr)
        :return: tuple: (bool fixedSomething, set omrPreIdsToIgnore, set midiPreIdsToIgnore)
        '''
        correspondingElements = self.getCorrespondingElementsFromPreId(omrPreId, changeList)
        if correspondingElements is None:
            return (False, set(), set())
        omrPreElem, omrPostElem, midiPreElem, midiPostElem = correspondingElements

        omrPreIdsToIgnoreIfFix = set()
        midiPreIdsToIgnoreIfFix = set()

        if not omrPreElem.isNote or not midiPreElem.isNote:
            return (False, set(), set())
        if omrPreElem.pitch == midiPreElem.pitch:
            return (False, set(), set())

        # Add the impacted notes if correct something
        for i, c in changeList:
            midiPreIdsToIgnoreIfFix.add(i)
        omrPreIdsToIgnoreIfFix.add(omrPreId)

        # different representation of same pitch
        if omrPreElem.pitch.isEnharmonic(midiPreElem.pitch):
            # keep omr representation
            markConfidentFix(omrPostElem)
            # now update midi
            midiPostElem.pitch = deepcopy(omrPreElem.pitch)
            markConfidentFix(midiPostElem)
            return (True, omrPreIdsToIgnoreIfFix, midiPreIdsToIgnoreIfFix)

        # if omr has a natural --> try removing it (which ends up turning it to one of these) or turning it into a flat
        natural = pitch.Accidental('natural')
        if omrPreElem.pitch.accidental is None or omrPreElem.pitch.accidental == natural:
            newDownPitch = omrPreElem.pitch.transpose('-m2')
            newUpPitch = omrPreElem.pitch.transpose('m2')
            if newDownPitch.isEnharmonic(midiPreElem.pitch):
                omrPostElem.pitch.accidental = pitch.Accidental('flat')
                markConfidentFix(omrPostElem)
                midiPostElem.pitch = deepcopy(omrPostElem.pitch)
                markConfidentFix(midiPostElem)
                return (True, omrPreIdsToIgnoreIfFix, midiPreIdsToIgnoreIfFix)
            if newUpPitch.isEnharmonic(midiPreElem.pitch):
                omrPostElem.pitch.accidental = pitch.Accidental('sharp')
                markConfidentFix(omrPostElem)
                midiPostElem.pitch = deepcopy(omrPostElem.pitch)
                markConfidentFix(midiPostElem)
                return (True, omrPreIdsToIgnoreIfFix, midiPreIdsToIgnoreIfFix)

        # if has a sharp --> try putting a natural or removing it (this is the same thing?) (transpose down)
        # removing is better? (will add the natural if necessary?)
        # assume sharps, flat not confused
        elif omrPreElem.pitch.accidental == pitch.Accidental('sharp'):
            newPitch = omrPreElem.pitch.transpose('-m2')  # down
            if newPitch.isEnharmonic(midiPreElem.pitch):
                omrPostElem.pitch.accidental = None
                markConfidentFix(omrPostElem)
                midiPostElem.pitch = deepcopy(omrPostElem.pitch)
                markConfidentFix(midiPostElem)
                return (True, omrPreIdsToIgnoreIfFix, midiPreIdsToIgnoreIfFix)

        # if has a flat --> try putting as a natural or removing it
        # assume sharps, flats not confused
        elif omrPreElem.pitch.accidental == pitch.Accidental('flat'):
            newPitch = omrPreElem.pitch.transpose('m2')  # up
            if newPitch.isEnharmonic(midiPreElem.pitch):
                omrPostElem.pitch.accidental = None
                markConfidentFix(omrPostElem)
                midiPostElem.pitch = deepcopy(omrPostElem.pitch)
                markConfidentFix(midiPostElem)
                return (True, omrPreIdsToIgnoreIfFix, midiPreIdsToIgnoreIfFix)

        return (False, set(), set())

    def fixerHelperDottedRhythm(self, omrPreId, changeList):
        '''
        Fixes when omr and midi have a differing duration due to misread dot for rhythm
        Modifies omrPost and midiPost of current generation and adds editorial info about fix if fixes

        :param omrPreId: id corresponding to a music21 element in the omrPre stream of current generation
        :param changeList: list of tuples (correspondingMidiPreElemId, change to get to that midi from omr)
        :return: tuple: (bool fixedSomething, set omrPreIdsToIgnore, set midiPreIdsToIgnore)

        # TODO needs to shift other offsets since fixed note will take up more or less space now!
        '''
        # extra or missing dot caused rhythm mismatch
        correspondingElements = self.getCorrespondingElementsFromPreId(omrPreId, changeList)
        if correspondingElements is None:
            return (False, set(), set())
        omrPreElem, omrPostElem, midiPreElem, midiPostElem = correspondingElements

        omrPreIdsToIgnore = set()
        midiPreIdsToIgnore = set()

        if not omrPreElem.isNote or not midiPreElem.isNote:
            return (False, set(), set())

        if omrPreElem.duration  == midiPreElem.duration:
            return (False, set(), set())

        # TODO currently doesn't care if share enharmonic pitch, but could give higher level of confidence?
        omrPreElemDurationCopy = deepcopy(omrPreElem.duration)
        midiPreElemDurationCopy = deepcopy(midiPreElem.duration)
        omrPreElemDurationCopy.dots = 0
        midiPreElemDurationCopy.dots = 0

        durationDifference = omrPreElemDurationCopy.quarterLength - midiPreElemDurationCopy.quarterLength
        if abs(durationDifference) <= self.eps:
            # keep midi duration
            omrPostElem.duration.quarterLength = midiPreElem.duration.quarterLength
            markConfidentFix(omrPostElem)
            markConfidentFix(midiPostElem)
            for i, c in changeList:
                midiPreIdsToIgnore.add(i)
            omrPreIdsToIgnore.add(omrPreId)
            fixedSomething = True
            return (True, omrPreIdsToIgnore, midiPreIdsToIgnore)

        return (False, set(), set())

    def fixOnePass(self) :
        '''
        Goes through all changes (that are not "no change") in latest generation of omrPre and midiPre
        Attempts to resolve them by modifying omrPost and midiPost, marking these changes on the editorial.correctionStatus
        as CONFIDENT_FIX or TENTATIVE_FIX.

        When a fix is made, don't make fixes to those element or related elements (derived from it in changes list)
        during any more passes of this call of the function.

        :return: True if fixed something, false otherwise
        '''
        fixerHelpers = [self.fixerHelperDifferentRestRep, self.fixerHelperDottedRhythm, self.fixerHelperPitchAccidentals]
        # TODO: should fixer helpers be a self.fixerHelpers initialized in the init??

        fixedSomething = False
        midiPreDontTouchIds = set() # includes ids that were in changes list when some fix was made (not necessarily to them)
        omrPreDontTouchIds = set()

        for problematicOmrPreId, changeList in self.omrPreIdToMidiPreIdRealChanges.items():
            correspondingMidiPreElemId, correspondingChange = changeList[0]
            if problematicOmrPreId in omrPreDontTouchIds or correspondingMidiPreElemId in midiPreDontTouchIds:
                continue

            for fixerHelper in fixerHelpers:
                fixed, omrPreIdsToIgnoreUpdates, midiPreIdsToIgnoreUpdates = fixerHelper(problematicOmrPreId, changeList)
                if fixed: # only update for fixed functions for no
                    for omrPreIdToIgnore in omrPreIdsToIgnoreUpdates:
                        omrPreDontTouchIds.add(omrPreIdToIgnore)
                    for midiPreIdToIgnore in midiPreIdsToIgnoreUpdates:
                        midiPreDontTouchIds.add(midiPreIdToIgnore)
                    fixedSomething = True
                    continue # don't try to fix anything else!!
        return fixedSomething

    def colorPart(self, part):
        '''
        :param part: music21 stream to mark elements with color corresponding to
            whether notes were fixed (confidently or tentatively), unable to be fixed,
            or have no issue
        '''
        for elem in part.recurse():
            if "correctionStatus" not in elem.editorial:
                elem.style.color = self.noDiscrepancyColor
            elif elem.editorial.correctionStatus == CONFIDENT_FIX:
                elem.style.color = self.confidentFixColor
            elif elem.editorial.correctionStatus == DISCREPANCY:
                elem.style.color = self.discrepancyColor
            elif elem.editorial.correctionStatus == TENTATIVE_FIX:
                elem.style.color = self.tentativeFixColor
            elif elem.editorial.correctionStatus == NO_DISCREPANCY:
                elem.style.color = self.noDiscrepancyColor

    def fix(self): # keeps looping through until all fixed!!
        '''
        Tries to fix the post versions of current generation
        Passes through making fixes until makes no more progress
        Realigns after each loop through the parts to fix
        :return: tuple (finalVersion, list of versions) where
            finalVersion is the score showing as returned by generateCorrectedScore for useFirstAligned = True
            versions are each a score showing as returned by generateCorrectedScore for useFirstAligned = False,
                using the latest generation of the score each time
        '''
        versions = []
        passCorrectedThings = self.fixOnePass()
        count = 1
        while passCorrectedThings:
            print("PASS NUMBER: ", count + 1)
            versions.append(self.generateCorrectedScore())
            self.makeNewPrePostGeneration()
            self.align()
            passCorrectedThings = self.fixOnePass()
            count += 1
            if count >= 7: #
                break
        if count == 1:
            # didn't enter while loop since nothing fixed
            # still want to generate corrected score (even though will be same as finalVersion)
            versions.append(self.generateCorrectedScore())
        finalVersion = self.generateCorrectedScore(show=False, useFirstAligned=True)
        return (finalVersion, versions) # returns the update score versions!

    def generateCorrectedScore(self, show=False, useFirstAligned = False):
        '''
        :param useFirstAligned: whether should show the first aligned (True) or the most recent generation (False)
        :param show: whether should have a pop up showing it
        :return: a copy of the score with all parts. Saves the generated score to the attribute or an error
        '''
        if not self.canCorrect:
            raise ValueError("Cannot correct this score. Run set up if you haven't already. Otherwise first fix concerns raised from set up.")
        if not self.hasBeenAligned:
            raise ValueError("Please first align the music. Run align.")

        scoreDisplay = stream.Score()

        if useFirstAligned:
            omrPrePartDisplay = self.getOmrPre(0)
            midiPrePartDisplay = self.getMidiPre(0)
        else:
            omrPrePartDisplay = self.getOmrPre()
            midiPrePartDisplay = self.getMidiPre()

        assert isinstance(midiPrePartDisplay, stream.Part)
        midiPrePartDisplay.partName = 'MIDI'
        midiPrePartDisplay.partAbbreviation = 'MIDI'
        midiPrePartDisplay.id = 'MIDI'

        assert isinstance(omrPrePartDisplay, stream.Part)
        omrPrePartDisplay.partName = 'OMR-pre'
        omrPrePartDisplay.partAbbreviation = 'OMR-pre'
        omrPrePartDisplay.id = 'OMR-pre'

        omrPostPart = self.getOmrPost()
        assert isinstance(omrPostPart, stream.Part)
        omrPostPart.partName = 'OMR-post'
        omrPostPart.partAbbreviation = 'OMR-post'
        omrPostPart.id = 'OMR-post'

        if self.groundTruthPart is not None:
            assert isinstance(self.groundTruthPart, stream.Part)
            self.groundTruthPart.partName = "Ground Truth"
            self.groundTruthPart.partAbbreviation = "Truth"
            self.groundTruthPart.id = "Ground Truth"

        # color OMR post
        self.colorPart(omrPostPart)

        scoreDisplay.append([midiPrePartDisplay, omrPrePartDisplay, omrPostPart])
        if self.groundTruthPart is not None:
            scoreDisplay.append(self.groundTruthPart)

        if show:
            self.scoreDisplay.show()

        return scoreDisplay


###### 1. LOAD CONTENT ######
# TODO: CHANGE THESE TO CORRECT FILEPATH TO RUN THIS CODE
haydnMidi = "/Users/janellesands/Desktop/MIT/meng/Research/Music/yale_midi_archive/Haydn/String Quartet Op1 No1 i Bb major.xml"
haydnOmr = "/Users/janellesands/Desktop/MIT/meng/Research/Music/omr/Haydn/mit39080016591155_fullViolin1_String_Quartet_Op1_No1.xml"

###### 2. PRE-FORMAT CONTENT ######
midi = converter.parse(haydnMidi)
omr = converter.parse(haydnOmr).measures(0,64)
groundTruth = corpus.parse('haydn/opus1no1/movement1').measures(0,63)

###### 3. RUN CORRECTOR ######
corrector = Corrector(midi, omr, groundTruth, 0)
corrector.setUp()
corrector.align()
finalScore, scores = corrector.fix()
finalScore.show()


###### OTHER FUNCTIONS ######
def findExamples(composer, ornament):
    exampleFiles = []
    files = corpus.getComposer(composer)
    for file in files:
        music = converter.parse(file)
        for n in music.recurse().notes:
            if n.expressions and any(isinstance(e, ornament) for e in n.expressions):
                exampleFiles.append(file)
                break
    return exampleFiles

def experimentFixer(midiFilePath, omrFilePath, fixer, part=None, midiMeasureRange=None, omrMeasureRange=None, chosenHasher=True): # chosen hasher arg needs changed tbd (originally None)
    '''
    range is tuple start finish of measures to include (start, finish), finish non-inclusive
    part is part #
    fixer is a fixer
    '''
    print("running experiment")
    # parse/format files
    midi = converter.parse(midiFilePath)
    omr = converter.parse(omrFilePath)
    if part is not None:
        midi = midi.parts[part]
        omr = omr.parts[part]
    if midiMeasureRange is not None:
        midi = midi.measures(midiMeasureRange[0], midiMeasureRange[1])
    if omrMeasureRange is not None:
        omr = omr.measures(omrMeasureRange[0], omrMeasureRange[1])
    print("parsed files")
    # set up hasher
    if chosenHasher is not None:
        print("hasher")
        chosenHasher = hasher.Hasher()
        chosenHasher.hashOffset = False
        chosenHasher.includeReference = True

    # aligner (hasher_func=chosenHasher)
    sa = aligner.StreamAligner(
        sourceStream=omr,
        targetStream=midi,
        hasher_func=chosenHasher
    )
    sa.align()
    sa.showChanges(show=True)
    print("alignment completed")

    # fixer
    # f = fixer(sa.changes, sa.targetStream, sa.sourceStream)
    # f.fix(show=True)

def experimentMarkBadNotes(midiFilePath, omrFilePath, part=None, midiMeasureRange=None, omrMeasureRange=None):
    midiOrig = converter.parse(midiFilePath)
    midi = midiOrig.chordify().measures(11,999).flat.getElementsByOffset(1.0,999999).stream()
    omr = converter.parse(omrFilePath)

    # if part is not None:
    #     midi = midi.parts[part]
    #     omr = omr.parts[part]
    # if midiMeasureRange is not None:
    #     midi = midi.measures(midiMeasureRange[0], midiMeasureRange[1])
    # if omrMeasureRange is not None:
    #     omr = omr.measures(omrMeasureRange[0], omrMeasureRange[1])

    for n in omr.flat.getElementsByClass('Note'):
        n_offset = n.offset
        midi_notes_at_offset = list(midi.getElementsByOffset(n_offset, mustBeginInSpan = False, mustFinishInSpan = False).notes)
        found_one = False
        print(n, midi_notes_at_offset)
        for midi_n in midi_notes_at_offset:
            if n.pitch.ps in [p.ps for p in midi_n.pitches]:
                found_one = True
        if not found_one:
            n.style.color = 'red'

    omr.show()






